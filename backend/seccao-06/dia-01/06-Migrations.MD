# Migrations

*Uma migration Ã© uma forma de versionar o schema do banco de dados.* Ou seja, cada migration conterÃ¡ um pedaÃ§o de cÃ³digo que representa o histÃ³rico das alteraÃ§Ãµes feitas no nosso banco de dados.

> Usando migrations, o mapeador objeto-relacional sabe exatamente quais alteraÃ§Ãµes executar no banco de dados, tanto para criar algo novo quanto para restaurar o banco para uma versÃ£o mais antiga. AlÃ©m disso, uma migration tem dois cÃ³digos conhecidos como Up e Down. Ou seja: toda migration, alÃ©m de saber o que fazer para executar as mudanÃ§as no banco de dados (Up), tambÃ©m deve saber como reverter essas mudanÃ§as (Down). Isso significa que as migrations tÃªm o poder de avanÃ§ar ou reverter o seu banco de dados para qualquer um dos estados que ele jÃ¡ teve.


# âž¡ï¸ Agora vamos gerar um novo arquivo, com apenas o â€œesqueletoâ€ de uma migration, usando o seguinte comando no terminal:

> npx sequelize migration:generate --name create-user


âž¡ï¸ Agora vamos mexer apenas dentro das funÃ§Ãµes up e down. Repare que ambas as funÃ§Ãµes recebem dois parÃ¢metros: um Ã© o queryInterface, e o outro Ã© o Sequelize. Ambos os parÃ¢metros sÃ£o objetos que armazenam dados e operaÃ§Ãµes.

1. O queryInterface
> Ã© usado pela biblioteca para modificar o banco de dados, seguindo o â€œdialetoâ€ do banco que estamos utilizando.

2. O objeto Sequelize
> armazena os tipos de dados disponÃ­veis no contexto do banco, por exemplo varchar, string, integer, date etc.

âž¡ï¸ O objetivo da nossa migration Ã© criar a tabela users com os seguintes campos e condiÃ§Ãµes:

1. id: Identificador do item.

> Ã‰ uma chave primÃ¡ria;
> Valor nÃ£o pode ser nulo;
> Possui incremento automÃ¡tico;
> Ã‰ do tipo Integer.

2. fullName: Nome completo da pessoa usuÃ¡ria da aplicaÃ§Ã£o.
> Ã‰ do tipo String.

3. email: E-mail da pessoa usuÃ¡ria da aplicaÃ§Ã£o.
> Ã‰ do tipo String.

4. createdAt: Data da criaÃ§Ã£o do item.
> Valor nÃ£o pode ser nulo;
> Ã‰ do tipo Date.

5. updatedAt: Data da atualizaÃ§Ã£o do item.
> Valor nÃ£o pode ser nulo;
> Ã‰ do tipo Date.


# Podemos criar a tabela Users atravÃ©s da funÃ§Ã£o createTable do queryInterface. A funÃ§Ã£o createTable recebe dois parÃ¢metros:

> O primeiro recebe uma string com o nome da tabela;

> O segundo recebe um objeto com os campos, e suas condiÃ§Ãµes, da tabela.

Lembra da convenÃ§Ã£o que mencionamos anteriormente, na qual o nome do model Ã© no singular e o nome da tabela Ã© no plural? Ã‰ por esta razÃ£o que na funÃ§Ã£o createTable o nome especificado serÃ¡ "Users". ðŸ˜‰


# âž¡ï¸ Para comeÃ§ar, chamamos a funÃ§Ã£o createTable passando o nome da tabela dentro do bloco de execuÃ§Ã£o (up):

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('Users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      fullName: {
        type: Sequelize.STRING
      },
      email: {
        type: Sequelize.STRING
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('Users');
  }
};


# âž¡ï¸ Percebeu que cada campo possui um objeto representando as propriedades daquele campo em especÃ­fico? Veja o que sÃ£o cada uma dessas propriedades:

allowNull: Define se o campo pode ou nÃ£o receber um valor null;
autoIncrement: Define se o campo vai ter incremento automÃ¡tico;
primaryKey: Define se o campo Ã© uma chave primÃ¡ria;
type: Define o tipo do campo, por exemplo STRING, INTEGER, DATE, etc.
âž¡ï¸ Agora vamos implementar o bloco de reversÃ£o (down) com um cÃ³digo que vai apenas apagar a tabela caso seja necessÃ¡rio desfazer a operaÃ§Ã£o de execuÃ§Ã£o (up). Assim escreveremos uma migration perfeitamente reversÃ­vel!


  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('Users');
  }


# Com a migration criada, basta executarmos o seguinte comando pelo CLI:


> env $(cat .env) npx sequelize db:migrate

Caso queira reverter uma migration use o seguinte comando:

> env $(cat .env) npx sequelize db:migrate:undo


# Criando uma nova migration para alterar uma tabela jÃ¡ existente


*âœ”ï¸ A resposta certa Ã©:* criar uma nova migration que permita alterar a tabela. Para isso, o objeto **queryInterface** possui funÃ§Ãµes especÃ­ficas, que permitem criar uma nova coluna, remover uma coluna ou mesmo mudar o tipo de uma coluna que jÃ¡ existe. Nesse caso, o queryInterface abstrai o que a funÃ§Ã£o ALTER TABLE faz no SQL. Deseja saber mais sobre ALTER TABLE e estÃ¡ com sua gestÃ£o de tempo em dia? Consulte o conteÃºdo adicional sobre o assunto.

https://app.betrybe.com/learn/course/5e938f69-6e32-43b3-9685-c936530fd326/module/f04cdb21-382e-4588-8950-3b1a29afd2dd/section/49fbc95c-1115-4c96-aded-1cba096dc9ed/lesson/815abac9-1bdf-46f5-a0ec-7813141e560b



### âž¡ï¸ Para criar uma outra migration para adicionar a coluna phoneNum na sua tabela Users, vocÃª deve criar um novo arquivo com o seguinte comando:

> npx sequelize migration:generate --name add-column-phone-table-users


âž¡ï¸ Com isso, um novo arquivo [timestamp]-add-column-phone-table-users.js serÃ¡ criado.

> âž¡ï¸ Agora podemos inserir a funÃ§Ã£o queryInterface.addColumn() no escopo Up para adicionar uma nova coluna Ã  nossa tabela Users, e adicionar a funÃ§Ã£o queryInterface.removeColumn() no escopo Down para remover a nova coluna da tabela. Veja como fazer isso a partir do cÃ³digo abaixo:


// src/migrations/[timestamp]-add-column-phone-table-users.js

'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
   await queryInterface.addColumn('Users', 'phoneNum', {
     type: Sequelize.STRING,
   });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Users', 'phoneNum');
  }
};

##
âž¡ï¸ Em seguida rodamos o comando abaixo para executar a nossa nova migration:

> env $(cat .env) npx sequelize db:migrate

##
âž¡ï¸ TambÃ©m devemos alterar o model user.model.js para incluir a nova coluna phoneNum da seguinte forma:

// src/models/user.model.js

// const User = (sequelize, DataTypes) => {
//   const User = sequelize.define('User', {
//     fullName: DataTypes.STRING,
//     email: DataTypes.STRING,
       // aqui inserimos o datatype da coluna criada
#       phoneNum: DataTypes.STRING,
//   });
// 
//   return User;
// };

// module.exports = User;





# Comando

npx sequelize model:generate --name books.model --attributes title:string,author:string,pageQuantity:integer

env $(cat .env) npx sequelize db:create


