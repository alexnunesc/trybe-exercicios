Inicialmente importamos a conex√£o com o MySQL do nosso outro m√≥dulo e, em seguida, editamos a fun√ß√£o insert para receber como par√¢metro um objeto person. Nela escrevemos o c√≥digo referente a um INSERT no banco de dados. Ent√£o, chamamos a fun√ß√£o conn.execute(), a qual recebe dois par√¢metros:

Uma string que cont√©m um INSERT de dados na tabela people. Note que a string foi definida utilizando-se crase para possibilitar a quebra de linhas, mas pode-se utilizar as aspas simples ou duplas;
Um array de valores que s√£o extra√≠dos do objeto person;
Vale destacar que no final da string que cont√©m o SQL INSERT, existem quatro sinais de interroga√ß√£o. Voc√™ pode estar se perguntando: ‚ÄúEsse SQL n√£o est√° escrito errado?‚Äù ü§î

Esses s√≠mbolos de interroga√ß√£o s√£o chamados de placeholders (ou marcadores, em portugu√™s). Sua fun√ß√£o √© de justamente marcar os locais que ser√£o substitu√≠das pelos valores dentro da consulta SQL.

E quais s√£o esses valores que substituir√£o os sinais de interroga√ß√£o? ü§î

S√£o justamente os valores do array que passamos como segundo par√¢metro da fun√ß√£o conn.execute()! A chamada da fun√ß√£o conn.execute() com os dois par√¢metros citados √© o que caracteriza uma prepared statement no mysql2.

Podemos pensar nas Prepared Statements como um template ou um molde para consultas SQL que uma aplica√ß√£o deseja executar, e que pode ser customizado utilizando vari√°veis de par√¢metros (os placeholders ou marcadores). Isso nos oferece dois grandes benef√≠cios:

As consultas SQL s√≥ necessitam ser preparadas uma √∫nica vez, entretanto podem ser executadas m√∫ltiplas vezes com os mesmos par√¢metros ou com par√¢metros diferentes. Quando uma consulta √© preparada, o banco de dados ir√° analisar, compilar e otimizar a execu√ß√£o da consulta;
Os par√¢metros das prepared statements n√£o devem ser vinculadas diretamente na consulta SQL (utilizando concatena√ß√£o de string, por exemplo). O recurso das prepared statements identifica os par√¢metros para o banco de dados, evitando que ele erroneamente interprete strings como parte da consulta. Se uma aplica√ß√£o utiliza prepared statements em todas as opera√ß√µes que realiza com o banco de dados, essas opera√ß√µes est√£o seguras contra o ataque do tipo SQL injection.
‚ö†Ô∏è Aten√ß√£o: SQL injection √© um tipo de ataque malicioso que uma aplica√ß√£o Web pode sofrer atrav√©s de inje√ß√£o de c√≥digo SQL em entradas que n√£o tratam os dados de forma adequada (e.g. formul√°rios, APIs REST, etc). O relat√≥rio anual de 2021 da Open Web Application Security Project (OWASP) apontou os ataques de inje√ß√£o (categoria do SQL injection) como o terceiro maior vetor de ataques maliciosos contra aplica√ß√µes Web. üò®

Na execu√ß√£o dessa prepared statement, os placeholders ser√£o substitu√≠dos pelos valores do array seguindo a mesma ordem nos quais eles foram declarados, ou seja, o primeiro placeholder ser√° substitu√≠do pelo primeiro valor do array; o segundo placeholder ser√° substitu√≠do pelo valor do segundo valor do array e assim sucessivamente at√© o √∫ltimo. Dessa forma, podemos reutilizar esse INSERT apenas passando valores diferentes para o array!

