Comece criando a pasta src/services e dentro dessa pasta, crie o arquivo passenger.service.js e o arquivo index.js, n√≥s iremos continuar usando o padr√£o barrel que vimos no dia anterior.


.
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js    
    ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.js
    ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îú‚îÄ‚îÄ integration
    ‚îÇ   ‚îî‚îÄ‚îÄ unit/
    ‚îÇ       ‚îî‚îÄ‚îÄ models
    ‚îú‚îÄ‚îÄ app.js
    ‚îî‚îÄ‚îÄ server.js


const { passengerModel } = require('../models');

const findAll = async () => {
  const passengers = await passengerModel.findAll();
  return { type: null, message: passengers };
};

module.exports = {
  findAll,
};


Aqui importamos o objeto passengerModel do diret√≥rio models e implementamos a fun√ß√£o findAll que, por sua vez, executa a fun√ß√£o passengerModel.findAll.

Por fim, essa fun√ß√£o retorna o objeto { type: null, message: passengers }. Esse √© um padr√£o que adotaremos nos retornos das fun√ß√µes do servi√ßo: quando o valor do atributo type for igual a null, isso significa que a opera√ß√£o foi bem sucedida e o atributo message possuir√° o retorno esperado. Contudo, em caso de falha, a propriedade type ser√° definida com um tipo de erro e a propriedade message com a respectiva mensagem de erro.




# Testando ele.

  Portanto comece criando a pasta services em test/unit e, na sequ√™ncia, crie o arquivo passenger.service.test.js; crie tamb√©m a pasta mocks e, dentro dessa pasta, o arquivo passenger.service.mock.js. Ap√≥s essas opera√ß√µes a sua estrutura de diret√≥rio ficar√° assim:

.
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js    
    ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.js
    ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îú‚îÄ‚îÄ integration
    ‚îÇ   ‚îî‚îÄ‚îÄ unit/
    ‚îÇ       ‚îî‚îÄ‚îÄ models/
    ‚îÇ       ‚îî‚îÄ‚îÄ services/
    ‚îÇ           ‚îú‚îÄ‚îÄ mocks/
    ‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.mock.js
    ‚îÇ           ‚îî‚îÄ‚îÄ passenger.service.test.js  
    ‚îú‚îÄ‚îÄ app.js
    ‚îî‚îÄ‚îÄ server.js



> Agora escreveremos o teste da fun√ß√£o findAll. Aqui √© interessante partir da premissa que j√° escrevemos o teste da fun√ß√£o findAll na camada Model e o que agora s√≥ precisamos testar o comportamento da fun√ß√£o findAll do servi√ßo. Dessa forma, vamos usar o sinon.stub para mockar a chamada da fun√ß√£o da camada Model para retorna o array que definimos anteriormente (allPassengers).

üìù**Anote a√≠**: Note que a medida que vamos subindo de camada, o dubl√™ sempre √© feito para a camada inferior. Na camada Model, criamos um dubl√™ para o banco de dados, agora na camada Service criamos um dubl√™ para a camada Model e quando chegarmos na camada Controller, criaremos um dubl√™ para a camada Service.

#
const { expect } = require('chai');
const sinon = require('sinon');
const { passengerService } = require('../../../src/services');
const { passengerModel } = require('../../../src/models');

const { allPassengers } = require('./mocks/passenger.service.mock');

describe('Verificando service pessoa passageira', function () {
  describe('listagem de pessoas passageiras', function () {
    it('retorna a lista completa de pessoas passageiras', async function () {
      // arrange
      sinon.stub(passengerModel, 'findAll').resolves(allPassengers);
      
      // act
      const result = await passengerService.findAll();

      // assert
      expect(result.type).to.be.equal(null);
      expect(result.message).to.deep.equal(allPassengers);
    });
  });
  
   afterEach(function () {
     sinon.restore();
   });
 });
#

Perceba que realizamos primeiro o arranjo, mockando a fun√ß√£o passengerModel.findAll. Na sequ√™ncia invocamos a a√ß√£o que foi chamar a fun√ß√£o passengerService.findAll() e guardar o seu retorno na vari√°vel result, e ent√£o fazemos a asser√ß√£o para verificar se este objeto retornado tem o atributo type sendo igual a null e que o atributo message possui valor igual ao array mockado.



# Implementando a busca por id.

A fun√ß√£o findById possui a responsabilidade de solicitar a camada Model a busca de uma pessoa passageira pelo seu respectivo id, por√©m essa fun√ß√£o ter√° outras responsabilidades, tais como, validar as regras de neg√≥cios. Quando se busca uma pessoa passageira pelo id, √© importante validar duas regras:

> üî∑ O id deve ser um n√∫mero inteiro e o valor deve ser no m√≠nimo 1.

> üî∑ Deve existir uma pessoa passageira com o id informado.

Para implementar esse comportamento vamos seguir algumas etapas:

Criar um schema atrav√©s do **JOI**
Como lidaremos com valida√ß√µes, iremos centraliz√°-las na camada Service em um √∫nico arquivo. Para isso, crie uma pasta chamada validations dentro de **src/services/**. Em seguida, crie um arquivo chamado s**chemas.js**.

.
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ validations/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas.js    
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.js
    ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îú‚îÄ‚îÄ integration
    ‚îÇ   ‚îî‚îÄ‚îÄ unit/
    ‚îÇ       ‚îî‚îÄ‚îÄ models/    
    ‚îÇ       ‚îî‚îÄ‚îÄ services/
    ‚îÇ           ‚îú‚îÄ‚îÄ mocks/
    ‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.mock.js
    ‚îÇ           ‚îî‚îÄ‚îÄ passenger.service.test.js
    ‚îú‚îÄ‚îÄ app.js
    ‚îî‚îÄ‚îÄ server.js

# Neste arquivo, estabeleceremos o formato dos dados (schema) que esperamos receber em uma solicita√ß√£o de nosso servi√ßo. Ap√≥s estabelecermos esses crit√©rios, vamos criar as valida√ß√µes de acordo com eles em conjunto com as regras do neg√≥cio.

Utilizaremos o m√≥dulo Joi para nos auxiliar com as valida√ß√µes durante a escrita, onde o mesmo encontra-se instalado em nosso projeto. Caso deseje instalar o Joi em outros projetos, execute o seguinte comando:

>   npm install -E joi@17.6.0


Em seguida, vamos utiliz√°-lo para construir o molde da valida√ß√£o do id:

// src/services/validations/schemas.js

const Joi = require('joi');

const idSchema = Joi.number().integer().min(1).required();

module.exports = {
  idSchema,
};


# Aqui usamos o Joi para criar um schema de valida√ß√£o para realizar uma valida√ß√£o qualitativa de uma vari√°vel. Em outras palavras, vamos verificar se o valor da vari√°vel obedece aos seguintes crit√©rios:

> deve ser um n√∫mero (number());
> inteiro (integer());
> deve ser no m√≠nimo 1 (min(1));
> n√£o pode ser nulo (required()).

# Validando a partir do schema
  Agora que j√° definimos nossa valida√ß√£o atrav√©s de um schema, precisamos estabelecer o padr√£o de resposta considerando a valida√ß√£o definida. Para isso, crie na pasta validations o arquivo validationsInputValues.js.

  .
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îú‚îÄ‚îÄ validations/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas.js    
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validationsInputValues.js
    ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.js
    ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îú‚îÄ‚îÄ integration
    ‚îÇ   ‚îî‚îÄ‚îÄ unit/
    ‚îÇ       ‚îî‚îÄ‚îÄ services/
    ‚îÇ           ‚îú‚îÄ‚îÄ mocks/
    ‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ passenger.service.mock.js
    ‚îÇ           ‚îî‚îÄ‚îÄ passenger.service.test.js
    ‚îú‚îÄ‚îÄ app.js
    ‚îî‚îÄ‚îÄ server.js

# √â neste arquivo que iremos utilizar os moldes (schemas) criados no arquivo schemas.js e definir o retorno em caso de erro.

// src/services/validations/validationsInputValues.js

const { idSchema } = require('./schemas');

const validateId = (id) => {
  const { error } = idSchema.validate(id);
  if (error) return { type: 'INVALID_VALUE', message: '"id" must be a number' };
  
  return { type: null, message: '' };
};

module.exports = {
  validateId,
};


# Perceba aqui que temos dois fluxos:

  > Se o id n√£o obedecer alguma das regras no schema vai ser retornado o objeto onde o valor de type √© igual a INVALID_VALUE e o atributo message ser√° "id" must be a number indicando o erro.

  > Caso n√£o aconte√ßa nenhum erro vamos retornar o objeto com type sendo null e a mensagem sendo uma string vazia para sinalizar que o id √© v√°lido.



# Implementar a fun√ß√£o findById
  No arquivo src/services/passenger.service.js adicione a fun√ß√£o findById e sua respectiva exporta√ß√£o.

  // const passengerModel = require('../models/passenger.model');
const schema = require('./validations/validationsInputValues');

// ...

const findById = async (passengerId) => {
  const error = schema.validateId(passengerId);
  if (error.type) return error;

  const passenger = await passengerModel.findById(passengerId);
  if (!passenger) return { type: 'PASSENGER_NOT_FOUND', message: 'Passenger not found' };

  return { type: null, message: passenger };
};

// module.exports = {
//   findAll,
     findById,
// };


# Essa fun√ß√£o come√ßa usando a fun√ß√£o schema.validateId para verificar se o id √© v√°lido ou n√£o. Caso seja inv√°lido, a fun√ß√£o retorna o objeto de erro retornado e encerra a sua execu√ß√£o. Caso contr√°rio, o pr√≥ximo passo √© buscar a pessoa passageira pelo id, usando a camada Model. Por√©m, se for retornado um valor nulo da camada Model, a fun√ß√£o cai no segundo bloco if e retorna o objeto:


{ type: 'PASSENGER_NOT_FOUND', message: 'Passenger not found' };

Se existir uma pessoa passageira com esse id. A fun√ß√£o retornar√° o objeto padronizado, sinalizando que n√£o aconteceu nenhum erro (type: null) e que o atributo message receber√° o objeto da pessoa passageira encontrada (passenger)

# { bloco de c√≥digo } #

Perceba que esse teste √© mais robusto, pois contempla tr√™s poss√≠veis fluxos:

  > 1. O id recebido √© inv√°lido. Nesse caso o servi√ßo retorna um objeto com o atributo type com o valor INVALID_VALUE e o atributo message com valor "id" must be a number

  > 2. O id √© v√°lido mas a camada Model retorna um objeto nulo ao chamar a fun√ß√£o (simulando a inexist√™ncia de uma linha na tabela passengers com esse id). Nesse caso o servi√ßo retorna um objeto possuindo o atributo type com o valor PASSENGER_NOT_FOUND e o atributo message com valor Passenger not found.

  > 3. Existe um passageiro com o id enviado e o servi√ßo retorna um objeto com o atributo type com o valor null e o atributo message com o objeto passageiro encontrado.


üìù**Anote a√≠:** Cada it faz o teste de um desses fluxos, garantindo que testamos todas as possibilidades que essa fun√ß√£o pode seguir. Podemos pensar os casos de teste da seguinte forma: Sempre que voc√™ tiver um if (ou alguma estrutura condicional) voc√™ vai precisar de pelo menos mais um it para testar o caminho quando a condi√ß√£o √© verdadeira. Portanto, como temos dois ifs dentro da fun√ß√£o findById, logo temos um it para atender cada um desses casos e um outro it para o caminho feliz (um id v√°lido e que existe no banco √© passado como par√¢metro).


# ü§î Voc√™ pode estar se perguntando: Por que no primeiro teste (it) n√£o foi feito um arranjo para definir um dubl√™ para passengerModel.findBydId()?

Resposta: No cen√°rio onde a fun√ß√£o findById recebe um id inv√°lido, a fun√ß√£o passengerModel.findById() n√£o ser√° chamada, o que torna desnecess√°rio definir um dubl√™. Seguiremos com essa premissa sempre que tivermos valida√ß√µes que n√£o exijam opera√ß√µes de leitura ou escrita no banco de dados.

