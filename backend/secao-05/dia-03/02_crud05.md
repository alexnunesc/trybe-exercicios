# Implementando um CRUD do zero - Parte 5 - Camada Controller.



## Listagem de pessoas passageiras.

Vamos começar implementando a função responsável por lidar com a requisição de listar pessoas passageiras.

Começaremos criando a pasta src/controllers e dentro dela o arquivo passenger.controller.js com o seguinte conteúdo.


#
  const { passengerService } = require('../services');

  const listPassengers = async (_req, res) => {
    const { type, message } = await passengerService.findAll();

    if (type) return res.status(500).json(message);

    res.status(200).json(message);
  };

  module.exports = {
    listPassengers,
  };
#


⏮ Recapitulando: Se o atributo type for igual a null, quer dizer que o serviço vai retornar o que desejamos no atributo message, caso contrário, type retorna um código de erro e message uma string com o erro que aconteceu.

Como estamos usando esse contrato, vamos criar um if para avaliar se o valor de type é diferente de null, e caso seja, vamos fazer com que a requisição responda com o status HTTP 500 e a mensagem de erro retornada pelo service.

Caso o service retorne o valor de type sendo igual a null, a resposta da requisição vai ter o status HTTP 200 e o retorno vai ser a variável message que nesse cenário é o array de pessoas passageiras.

# Definindo barrel da camada Controllers
Para manter o padrão barrel também na nossa pasta src/controllers, crie o arquivo index.js com o seguinte conteúdo.

#
  const passengerController = require('./passenger.controller');

  module.exports = {
    passengerController,
  };
#

# Nossa estruturar agora.
.
└── src/
    ├── controllers/
    │   ├── index.js
    │   └── passenger.controller.js
    ├── models/
    ├── services/
    ├── app.js
    └── server.js

# Testando.


#
  // tests/unit/controllers/mocks/passenger.controller.mock

  // Vamos utilizar esse objeto como mock da função createPassenger que ainda vamos implementar.
  const passengerMock = {
    name: 'Bruce Lane',
    email: 'bruce.lane@acme.com',
    phone: '(77) 8179-0943',
  };

  // Vamos utilizar esse objeto como mock da função createPassenger que ainda vamos implementar.
  const newPassengerMock = { id: 1, ...passengerMock };

  // Esse é o array que utilizamos no teste da função findAll, reaproveitando o objeto newPassengerMock
  const passengerListMock = [newPassengerMock];

  module.exports = {
    passengerMock,
    newPassengerMock,
    passengerListMock,
  };
#

# Agora vamos para a implementação do teste da função listPassengers. Para isso crie o diretório tests/unit/controllers e dentro desse diretório crie o arquivo pas

#
// tests/unit/controllers/passenger.controller.test.js

const chai = require('chai');
const sinon = require('sinon');
const sinonChai = require('sinon-chai');

const { expect } = chai;
chai.use(sinonChai);

const { passengerService } = require('../../../src/services');
const { passengerController } = require('../../../src/controllers');
const {
  passengerListMock,
} = require('./mocks/passenger.controller.mock');

describe('Teste de unidade do passengerController', function () {
  describe('Listando as pessoas passageiras', function() {
    it('Deve retornar o status 200 e a lista', async function () {
      // arrange
      const res = {};
      const req = {};
      
      res.status = sinon.stub().returns(res);
      res.json = sinon.stub().returns();
      sinon
        .stub(passengerService, 'findAll')
        .resolves({ type: null, message: passengerListMock });

      // act
      await passengerController.listPassengers(req, res);

      // assert
      expect(res.status).to.have.been.calledWith(200);
      expect(res.json).to.have.been.calledWith(passengerListMock);
    });
  });
  
  afterEach(function () {
    sinon.restore();
  });
});
#


Note que o teste da camada Controller utiliza algumas novidades na etapa de arranjo e de asserção, comparado a camada Model e Service. Aqui é importante lembrar que estamos testando uma função que recebe como dois parâmetros, objetos criados pelo módulo express. Portanto, nosso dublê precisa emular o funcionamento das funções desses objetos.

Vamos entender com mais profundidade como esse teste unitário foi feito, pois isso nos ajudará a entender a anatomia do teste das funções do componente Controller.



Na sequência configuramos o chai para adicionar esse plugin através do uso do trecho chai.use(sinonChai);.

Definimos um describe mais amplo para o controller de pessoas passageiras, e dentro um describe específico para função passengerController.listPassengers e dentro desse describe adicionamos o caso de teste ‘Deve retornar o status 200 e a lista’.

Neste teste é possível perceber que o arranjo tem várias linhas, começando por uma criação de dublês para os objetos res e req, que são os parâmetros esperados para função passengerController.listPassengers por ser um middleware do Express.


const res = {};
const req = {};


Se voltarmos ao nosso código da função listPassengers perceberemos que não usamos o objeto req dentro da função e por isso, o dublê com um objeto vazio será o suficiente para esse caso de teste. Por outro lado, o objeto res é utilizado para definir o status HTTP e o corpo da resposta através das linhas que seguem o formato res.status().json().

Portanto para fazer as asserções do comportamento da função listPassengers vamos precisar usar um recurso do módulo sinon: Um espião de teste (Spies) 🕵🏼‍♀️. Esse recurso permite criar um dublê para uma função de um objeto e verificar se essa função foi chamada e até saber com quais parâmetros ela foi chamada. Para definir esse dublê do tipo spy, fazemos o seguinte arranjo:

https://sinonjs.org/releases/latest/spies/

res.status = sinon.stub().returns(res);
res.json = sinon.stub().returns();


Note que usamos a função sinon.stub() de uma forma diferente da que usamos nas outras camadas: desta vez não estamos passando nenhum parâmetro para essa função do módulo sinon. O que fizemos aqui foi definir que o atributo status do objeto res vai receber uma função spy que retorna o próprio objeto res. Fizemos algo parecido com res.json mas dessa vez sem usar nada no returns. Você deve estar se perguntando: Por quê no res.status o dublê retorna o próprio objeto res e no json não?

Para responder isso, vamos lembrar a forma que utilizamos o objeto res em um middleware:

res.status(200).json(message)


Note que nessa linha de código, acontece a chamada de duas funções em sequência: status(200) e json(message) tudo a partir de um mesmo objeto (res). Se refletirmos um pouco, podemos perceber que a função status() é executada antes da função json(), o retorno da chamada de status() é um objeto que deve conter a função json(), caso o contrário esse código gera um erro.

É exatamente isso o que dublê da função res.status() faz: Garantir que essa função retorne o objeto res que também possui a função json. Porém, depois da função json() não existe nenhuma outra função sendo chamada, o que torna desnecessário fazer com que o dublê da função json() retorne um objeto.

O último passo para finalizar o arranjo desse teste é definir o que o service vai retornar nesse cenário. Portanto vamos criar um dublê para função passengerService.findAll() que vai nos retornar um objeto seguindo o contrato da camada Service. Nesse caso, o atributo type é igual a null e o atributo message é o array mockado.

#
  sinon
      .stub(passengerService, 'findAll')
      .resolves({ type: null, message: passengerListMock });
#

# ⏮ Recapitulando: Comentamos anteriormente que o teste de cada camada cria dublês para funções da camada inferior: O teste do Controller cria dublês para funções da camada Service, o teste da camada Service cria dublês para funções da camada Model e a camada Model por sua vez cria dublês das funções do módulo do banco de dados, no nosso caso o módulo mysql2.

Continuando nosso teste e seguindo o padrão Triple A, temos que definir ação que nesse caso é simplesmente chamar a função do componente Controller passando como parâmetros os dublês dos objetos req e res.


> await passengerController.listPassengers(req, res);

# Agora vamos para a parte final do nosso teste: as asserções. Nesse caso, temos dois comportamentos esperados:

> 1. 1️⃣ a função res.status() deve ser chamada com o parâmetro 200.

 Para fazer essa asserção, usamos o expect passando como argumento res.status e o matcher .to.have.been.calledWith, conseguimos usar esse matcher graças ao arranjo.

#
  expect(res.status).to.have.been.calledWith(200);
#

> 2. 2️⃣ a função res.json deve ser chamada com o array retornada pelo service.

  Novamente usamos como expect uma função spy 🕵🏼‍♀️, no caso res.json e o matcher to.have.been.calledWith com o array mockado.
  
#
  expect(res.json).to.have.been.calledWith(passengerListMock);
#






















  

