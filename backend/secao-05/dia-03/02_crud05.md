# Implementando um CRUD do zero - Parte 5 - Camada Controller.



## Listagem de pessoas passageiras.

Vamos comeÃ§ar implementando a funÃ§Ã£o responsÃ¡vel por lidar com a requisiÃ§Ã£o de listar pessoas passageiras.

ComeÃ§aremos criando a pasta src/controllers e dentro dela o arquivo passenger.controller.js com o seguinte conteÃºdo.


#
  const { passengerService } = require('../services');

  const listPassengers = async (_req, res) => {
    const { type, message } = await passengerService.findAll();

    if (type) return res.status(500).json(message);

    res.status(200).json(message);
  };

  module.exports = {
    listPassengers,
  };
#


â® Recapitulando: Se o atributo type for igual a null, quer dizer que o serviÃ§o vai retornar o que desejamos no atributo message, caso contrÃ¡rio, type retorna um cÃ³digo de erro e message uma string com o erro que aconteceu.

Como estamos usando esse contrato, vamos criar um if para avaliar se o valor de type Ã© diferente de null, e caso seja, vamos fazer com que a requisiÃ§Ã£o responda com o status HTTP 500 e a mensagem de erro retornada pelo service.

Caso o service retorne o valor de type sendo igual a null, a resposta da requisiÃ§Ã£o vai ter o status HTTP 200 e o retorno vai ser a variÃ¡vel message que nesse cenÃ¡rio Ã© o array de pessoas passageiras.

# Definindo barrel da camada Controllers
Para manter o padrÃ£o barrel tambÃ©m na nossa pasta src/controllers, crie o arquivo index.js com o seguinte conteÃºdo.

#
  const passengerController = require('./passenger.controller');

  module.exports = {
    passengerController,
  };
#

# Nossa estruturar agora.
.
â””â”€â”€ src/
    â”œâ”€â”€ controllers/
    â”‚   â”œâ”€â”€ index.js
    â”‚   â””â”€â”€ passenger.controller.js
    â”œâ”€â”€ models/
    â”œâ”€â”€ services/
    â”œâ”€â”€ app.js
    â””â”€â”€ server.js

# Testando.


#
  // tests/unit/controllers/mocks/passenger.controller.mock

  // Vamos utilizar esse objeto como mock da funÃ§Ã£o createPassenger que ainda vamos implementar.
  const passengerMock = {
    name: 'Bruce Lane',
    email: 'bruce.lane@acme.com',
    phone: '(77) 8179-0943',
  };

  // Vamos utilizar esse objeto como mock da funÃ§Ã£o createPassenger que ainda vamos implementar.
  const newPassengerMock = { id: 1, ...passengerMock };

  // Esse Ã© o array que utilizamos no teste da funÃ§Ã£o findAll, reaproveitando o objeto newPassengerMock
  const passengerListMock = [newPassengerMock];

  module.exports = {
    passengerMock,
    newPassengerMock,
    passengerListMock,
  };
#

# Agora vamos para a implementaÃ§Ã£o do teste da funÃ§Ã£o listPassengers. Para isso crie o diretÃ³rio tests/unit/controllers e dentro desse diretÃ³rio crie o arquivo pas

#
// tests/unit/controllers/passenger.controller.test.js

const chai = require('chai');
const sinon = require('sinon');
const sinonChai = require('sinon-chai');

const { expect } = chai;
chai.use(sinonChai);

const { passengerService } = require('../../../src/services');
const { passengerController } = require('../../../src/controllers');
const {
  passengerListMock,
} = require('./mocks/passenger.controller.mock');

describe('Teste de unidade do passengerController', function () {
  describe('Listando as pessoas passageiras', function() {
    it('Deve retornar o status 200 e a lista', async function () {
      // arrange
      const res = {};
      const req = {};
      
      res.status = sinon.stub().returns(res);
      res.json = sinon.stub().returns();
      sinon
        .stub(passengerService, 'findAll')
        .resolves({ type: null, message: passengerListMock });

      // act
      await passengerController.listPassengers(req, res);

      // assert
      expect(res.status).to.have.been.calledWith(200);
      expect(res.json).to.have.been.calledWith(passengerListMock);
    });
  });
  
  afterEach(function () {
    sinon.restore();
  });
});
#


Note que o teste da camada Controller utiliza algumas novidades na etapa de arranjo e de asserÃ§Ã£o, comparado a camada Model e Service. Aqui Ã© importante lembrar que estamos testando uma funÃ§Ã£o que recebe como dois parÃ¢metros, objetos criados pelo mÃ³dulo express. Portanto, nosso dublÃª precisa emular o funcionamento das funÃ§Ãµes desses objetos.

Vamos entender com mais profundidade como esse teste unitÃ¡rio foi feito, pois isso nos ajudarÃ¡ a entender a anatomia do teste das funÃ§Ãµes do componente Controller.



Na sequÃªncia configuramos o chai para adicionar esse plugin atravÃ©s do uso do trecho chai.use(sinonChai);.

Definimos um describe mais amplo para o controller de pessoas passageiras, e dentro um describe especÃ­fico para funÃ§Ã£o passengerController.listPassengers e dentro desse describe adicionamos o caso de teste â€˜Deve retornar o status 200 e a listaâ€™.

Neste teste Ã© possÃ­vel perceber que o arranjo tem vÃ¡rias linhas, comeÃ§ando por uma criaÃ§Ã£o de dublÃªs para os objetos res e req, que sÃ£o os parÃ¢metros esperados para funÃ§Ã£o passengerController.listPassengers por ser um middleware do Express.


const res = {};
const req = {};


Se voltarmos ao nosso cÃ³digo da funÃ§Ã£o listPassengers perceberemos que nÃ£o usamos o objeto req dentro da funÃ§Ã£o e por isso, o dublÃª com um objeto vazio serÃ¡ o suficiente para esse caso de teste. Por outro lado, o objeto res Ã© utilizado para definir o status HTTP e o corpo da resposta atravÃ©s das linhas que seguem o formato res.status().json().

Portanto para fazer as asserÃ§Ãµes do comportamento da funÃ§Ã£o listPassengers vamos precisar usar um recurso do mÃ³dulo sinon: Um espiÃ£o de teste (Spies) ğŸ•µğŸ¼â€â™€ï¸. Esse recurso permite criar um dublÃª para uma funÃ§Ã£o de um objeto e verificar se essa funÃ§Ã£o foi chamada e atÃ© saber com quais parÃ¢metros ela foi chamada. Para definir esse dublÃª do tipo spy, fazemos o seguinte arranjo:

https://sinonjs.org/releases/latest/spies/

res.status = sinon.stub().returns(res);
res.json = sinon.stub().returns();


Note que usamos a funÃ§Ã£o sinon.stub() de uma forma diferente da que usamos nas outras camadas: desta vez nÃ£o estamos passando nenhum parÃ¢metro para essa funÃ§Ã£o do mÃ³dulo sinon. O que fizemos aqui foi definir que o atributo status do objeto res vai receber uma funÃ§Ã£o spy que retorna o prÃ³prio objeto res. Fizemos algo parecido com res.json mas dessa vez sem usar nada no returns. VocÃª deve estar se perguntando: Por quÃª no res.status o dublÃª retorna o prÃ³prio objeto res e no json nÃ£o?

Para responder isso, vamos lembrar a forma que utilizamos o objeto res em um middleware:

res.status(200).json(message)


Note que nessa linha de cÃ³digo, acontece a chamada de duas funÃ§Ãµes em sequÃªncia: status(200) e json(message) tudo a partir de um mesmo objeto (res). Se refletirmos um pouco, podemos perceber que a funÃ§Ã£o status() Ã© executada antes da funÃ§Ã£o json(), o retorno da chamada de status() Ã© um objeto que deve conter a funÃ§Ã£o json(), caso o contrÃ¡rio esse cÃ³digo gera um erro.

Ã‰ exatamente isso o que dublÃª da funÃ§Ã£o res.status() faz: Garantir que essa funÃ§Ã£o retorne o objeto res que tambÃ©m possui a funÃ§Ã£o json. PorÃ©m, depois da funÃ§Ã£o json() nÃ£o existe nenhuma outra funÃ§Ã£o sendo chamada, o que torna desnecessÃ¡rio fazer com que o dublÃª da funÃ§Ã£o json() retorne um objeto.

O Ãºltimo passo para finalizar o arranjo desse teste Ã© definir o que o service vai retornar nesse cenÃ¡rio. Portanto vamos criar um dublÃª para funÃ§Ã£o passengerService.findAll() que vai nos retornar um objeto seguindo o contrato da camada Service. Nesse caso, o atributo type Ã© igual a null e o atributo message Ã© o array mockado.

#
  sinon
      .stub(passengerService, 'findAll')
      .resolves({ type: null, message: passengerListMock });
#

# â® Recapitulando: Comentamos anteriormente que o teste de cada camada cria dublÃªs para funÃ§Ãµes da camada inferior: O teste do Controller cria dublÃªs para funÃ§Ãµes da camada Service, o teste da camada Service cria dublÃªs para funÃ§Ãµes da camada Model e a camada Model por sua vez cria dublÃªs das funÃ§Ãµes do mÃ³dulo do banco de dados, no nosso caso o mÃ³dulo mysql2.

Continuando nosso teste e seguindo o padrÃ£o Triple A, temos que definir aÃ§Ã£o que nesse caso Ã© simplesmente chamar a funÃ§Ã£o do componente Controller passando como parÃ¢metros os dublÃªs dos objetos req e res.


> await passengerController.listPassengers(req, res);

# Agora vamos para a parte final do nosso teste: as asserÃ§Ãµes. Nesse caso, temos dois comportamentos esperados:

> 1. 1ï¸âƒ£ a funÃ§Ã£o res.status() deve ser chamada com o parÃ¢metro 200.

 Para fazer essa asserÃ§Ã£o, usamos o expect passando como argumento res.status e o matcher .to.have.been.calledWith, conseguimos usar esse matcher graÃ§as ao arranjo.

#
  expect(res.status).to.have.been.calledWith(200);
#

> 2. 2ï¸âƒ£ a funÃ§Ã£o res.json deve ser chamada com o array retornada pelo service.

  Novamente usamos como expect uma funÃ§Ã£o spy ğŸ•µğŸ¼â€â™€ï¸, no caso res.json e o matcher to.have.been.calledWith com o array mockado.
  
#
  expect(res.json).to.have.been.calledWith(passengerListMock);
#






















  

