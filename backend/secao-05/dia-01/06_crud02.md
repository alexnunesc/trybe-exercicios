# Implementando um CRUD do zero - Parte 2 - Camada Model.

  Continuando a li√ß√£o anterior vamos implementar a fun√ß√£o para inserir dados na tabela passengers. Para isso vamos fazer a seguinte mudan√ßa em src/models/passenger.model.js.

  <......codigo.......>

  Na sequ√™ncia definimos uma vari√°vel para receber uma string com os nomes das colunas que ser√£o gerados a partir dos nomes de atributo de um objeto. Para chegar nesse resultado foi usado uma combina√ß√£o de 4 recursos:

  > snakeize: Transforma o nome dos atributos para o padr√£o snake_case.

  > Object.keys: Cria o array com o nome dos atributos.

  > join: Transforma o array criado pelo Object.keys em uma string.


  O pr√≥ximo passo √© criar uma string formada por uma sequ√™ncia de caracteres ?, sendo uma ? para cada atributo e s√£o separados por v√≠rgulas. Essa constru√ß√£o permite utilizar o recurso do m√≥dulo mysql2 de preparar a opera√ß√£o a ser executada de forma segura. Nos referimos a essa funcionalidade como Prepared Statement. Como precisamos de um sinal de interroga√ß√£o para cada atributo, usamos novamente o Object.keys, por√©m sem a necessidade de aplicar o snakeize dessa vez, pois precisamos do array s√≥ para saber a quantidade de vezes que o map ser√° executado para gerar o array de ?. Ao final desse processo transformamos esse array em uma string usando novamente a fun√ß√£o join.


  > Portanto, se passarmos um objeto no seguinte formato para fun√ß√£o insert:

  {
    "name": "John Doe",
    "email": "johndoe@gmail.com",
    "phone": "99 99999-9999"
  }

  Os valores das vari√°veis columns e placeholders ser√£o respectivamente name, email, phone e ?, ?, ?. Caso houvesse algum atributo no padr√£o camelCase, a fun√ß√£o snakeize transformaria esse nome para o padr√£o snake_case. (Por exemplo: createdAt se tornaria created_at).

  O pr√≥ximo passo √© montar a query com o valor dessas duas vari√°veis e chamar a fun√ß√£o connection.execute.

  const [{ insertId }] = await connection.execute(
    `INSERT INTO passengers (${columns}) VALUE (${placeholders})`,
    [...Object.values(passenger)],
  );


  Perceba, que dessa vez estamos desestruturando o retorno usando [{ insertId }]. Fizemos isso, pois opera√ß√µes do tipo INSERT, UPDATE e DELETE retornam uma resposta em um formato diferente das opera√ß√µes do tipo SELECT. Dito isso, a fun√ß√£o retorna um array onde o primeiro elemento √© objeto que possui alguns atributos, dentre eles o insertId que √© o valor da chave prim√°ria gerada pelo banco de dados.

  Al√©m disso, passamos como segundo par√¢metro da fun√ß√£o connection.execute o valor [...Object.values(passenger)], ou seja, estamos pegando os valores que est√£o nos atributos do objeto e transformando em um array. Estamos aplicando o spread operator para espalhar os valores de Object.values(passenger) dentro do array que forma o segundo par√¢metro da fun√ß√£o connection.execute.


# Implementando o teste
  Vamos escrever o teste para essa fun√ß√£o?

  Antes de escrever o teste, precisaremos de um objeto para ser utilizado como par√¢metro para a fun√ß√£o passengerModel.insert. Para isso acrescente no arquivo de mock o seguinte objeto e sua respectiva exporta√ß√£o.


  // tests/unit/models/mocks/passenger.model.mock.js

  // ...

  const newPassenger = {
    name: 'Bruce Lane',
    email: 'bruce.lane@acme.com',
    phone: '(77) 8179-0943',
  };

  // module.exports = {
    // passengers,
    newPassenger,
  // };


  Primeiro, importamos o objeto newPassenger que vem do arquivo de mock para usarmos como par√¢metro da fun√ß√£o insert.

  Perceba que para refletir o retorno do connection.execute atrav√©s do sinon fizemos um arranjo para criar um dubl√™ para retornar um array com o objeto { insertId: 42 } (lembrando que o sinon.stub() precisa emular o retorno no mesmo formato que o real). Na linha seguinte, chamamos o m√©todo insert (a√ß√£o) e guardamos seu retorno na vari√°vel result. Na √∫ltima linha fazemos a asser√ß√£o de comparar se result √© igual ao valor 42, o valor que mockamos na primeira no arranjo. Execute esse teste agora e veja que ele passar√°.

  Perfeito, n√£o? J√° temos a camada Model pronta para fazer 3 das 5 opera√ß√µes b√°sicas de um CRUD. üéâ ü•≥ üéâ



